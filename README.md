#所做项目

**1：** ****Project: implement the naïve birthday attack of reduced SM3**

对SM3哈希算法尝试进行生日攻击寻找碰撞。截取hash值的前32位作为结果。前32位相同的视为找到一组碰撞。

设定寻找碰撞的长度为32位。

根据生日攻击的原理，需要随机搜索$2^{16}$个明文消息，计算其hash值并保存起来。最后对于整个集合进行排序，从头到尾查找是否有相同的两项。
规定集合中元素：

```c++
struct setNode
{
	uchar msg[65];
	int c32;
	ll c64;
	setNode() { memset(msg,0,sizeof(msg)); c32 = 0; c64 = 0; };
	bool operator < (const setNode other)const
	{
		return this->c64 < other.c64;
	}
};
```

其中，msg保存明文消息，c32，c64分别以整数形式保存hash值的前32位和前64位，这样做可以方便进行排序和比对。

然后，重载运算符，使得整个结构以前64位的数值作为排序依据，从小到大排列。

另外需要注意的是：**由于生日攻击只能保证有50%的概率找到一对碰撞，所以只执行一次攻击可能并不能找到碰撞。**

为了确保能得到答案，如果找不到碰撞，就重新执行一次整个攻击过程，直到找到一组碰撞。每次的成功概率是50%，因此最后重复执行的总次数不会很多。

**2：****Project: implement the Rho method of reduced SM3**

使用低存储的$\rho$方法寻找碰撞，在可接受的时间内暂时只能找到16位的碰撞。
本项目采取的方案是，初始随机选取明文对$m_1,m_2$。

每次迭代，计算$h_1=Hash(m_1),h_2=Hash(Hash(m_2))$。根据$\rho$方法的原理，最终一定可以成环，找到$h_1=h_2$的情况。


**3：** **Project: implement length extension attack for SM3, SHA256, etc.**

对SM3进行长度扩展攻击。

长度扩展攻击的背景是，为了安全性，某些hash函数添加了salt属性，其作用类似于密钥，作用于hash函数使得其产生不同的结果。如果不知道salt或其它类似的秘密信息，其他人不能计算出hash值。而如果使用长度扩展，则可以根据一组已知的消息哈希对来生成一个扩展消息，并能够计算出这个消息的hash值。

首先我们需要根据sm3的消息扩展规则，将原消息扩展至分组长度的整数倍，这样才能保证结果的一致性。然后进行扩展，产生新的消息。

根据sm3结构，我们控制的状态就是上一个分组的hash值。而前面已经得到了真实消息的hash值，那么可以将其作为参数传入sm3计算过程，令其只处理最后一个分组。这样最终得到了扩展后的信息对应的hash值。
项目使用了gmssl提供的sm3方法。

**4：** **Project: do your best to optimize SM3 implementation (software)**

使用宏定义、SIMD、算法优化等方法优化SM3，效果显著。
本项目中，使用了以下方法对SM4加密算法进行了优化。

- 函数调用改为宏定义
- 使用SIMD指令
- 算法优化

正常情况下，一个分组为128位。为了最大利用硬件的并行性，我们使用avx512指令集，同时对512位，也即4个分组进行处理，理论上可以直接将速度提高4倍。
为了提升效率，可将S盒与后续的循环移位变换$L$ 合并，采用查表方法


**5：** **Project: Impl Merkle Tree following RFC6962**

实现了Merkle Tree以及其存在性证明。

最关键的地方在于建树的过程。

最开始考虑的是递归建树方案。将整体的建立过程分解为：假设目前已经有了一颗结构正确的树，每次向已有的完全二叉树中添加新的点，并选择合适位置，使其仍保持完全二叉树形式，最后返回新的树结构。

递归的方案是可行的。然而这样的做法实际上每次添加一个点就要调用一次递归过程，当节点数量较多时会发生栈溢出。显然这不能承载$10^5$个节点的构造，因此必须选择循环的方式。

事实发现，递归其实是完全没有必要的。因为我们进行一轮迭代之后，需要的信息只是当前的树根节点就可以确认整棵树的状态，而没有其他的依赖。从树根向下寻找可插入的位置是$O(\log n)$的复杂度，速度很快。因此直接将递归过程修改为循环即可。

具体方法为：每添加一个点后返回当前的根节点指针，代表新的树结构。下次添加时，从根节点开始考虑。

**6：** **Project: impl sm2 with RFC6979**

根据RFC6979实现了对k的生成，在此基础上实现了SM2签名及其验证算法。

**7：** **Project: Implement a PGP scheme with SM2**

实现了基础的PGP模块，包括SM2密钥交换生成会话密钥、SM2加密会话密钥、根据会话密钥使用SM4对称加密会话数据三个部分。

**8：** **Project: implement sm2 2P sign with real network communication**

使用socket网络编程，在真实的网络环境下实现了SM2两方签名，并检查了验证签名的正确性。

**9：** **Project: implement sm2 2P decrypt with real network communication**

同样使用socket，实现了数据的两方加密和解密，并验证了加解密正确性。


**10：** **Project: Implement the above ECMH scheme**

实现了将集合hash到椭圆曲线点的ECMH方案，并验证了其同态性质。
